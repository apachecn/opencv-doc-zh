

# 图像基本操作

## 目标

学习：

* 访问像素值并修改它们
* 访问像素属性
* 设置感兴趣区域（ROI）
* 拆分和合并图像

本节中的几乎所有操作都主要与 Numpy 有关而非 OpenCV。熟悉 Numpy 后才能使用 OpenCV 编写更好的优化后代码。

（由于大多数代码都是单行的，所以示例将在 Python 终端中显示）

## 访问和修改像素值

先来理解图像与一般的矩阵或张量的不同之处(不考虑图像的格式，元数据等信息)。首先，一张图像有自己的属性：宽，高，通道数。其中宽和高是我们肉眼可见的属性，而通道数则是图像能呈现色彩的属性。我们都知道，光学三原色是红色，绿色和蓝色，这三种颜色的混合可以形成任意的颜色。常见的图像的像素通道也是对应的R，G，B三个通道，在OpenCV中，每个通道的取值范围为0～255。(注：还有RGBA，YCrCb，HSV等其他图像通道表示方法)。即，一般彩色图像读进内存之后是一个h * w * c的矩阵，其中h为图像高(相当于矩阵的行)，w为图像宽(相当于矩阵列)，c为通道数。

下面我们先加载一副彩色图像，更准确地说，是一副黄色图像，如图所示。

<div align=center>
<img src="https://opencv.apachecn.org/docs/img/yellow.jpg">
</div>

黄色为绿色和红色的混合。所以，该图像的所有像素值都应为R=255，G=255，B=0。

```python
>>> import numpy as np
>>> import CV2
>>> img = CV2.imread("img/yellow.jpg")
>>> h,w,c = img.shape
#图像大小为128*128*3
>>> print(h,w,c)
128 128 3
```
从上面的代码中可以看到，您可以通过行和列坐标访问像素值。注意，对于常见的RGB 图像，OpenCV的imread函数返回的是一个蓝色(Blue)值、绿色(Green)值、红色(Red)值的数组，维度大小为3。而对于灰度图像，仅返回相应的灰度值。

```python
>>> img[100,100]
#OpenCV的读取顺序为B，G，R，由于图像所有像素为黄色，因此，G=255，R=255
array([  0, 255, 255], dtype=uint8)

# 仅访问蓝色通道的像素
>>> blue = img[100,100,0]
>>> print(blue)
0
```
你也可以使用同样的方法来修改像素值。

```python
>>> img[100,100] = [255,255,255]
>>> print(img[100,100])
[255 255 255]
```

**警告**

Numpy 是一个用于快速阵列计算的优化库。因此，简单地访问每个像素值并修改其值将非常缓慢，并不鼓励这样做。

>**注意**
>上述方法通常用于选择数组的某个区域，比如前 5 行和后 3 列。对于单个像素的访问，可以选择使用 Numpy 数组方法中的 array.item()和 array.itemset()，注意它们的返回值是一个标量。如果需要访问所有的 G、R、B 的值，则需要所有像素分别调用 array.item()。

更好的访问和编辑像素的方法：

```python
#访问 红色通道 的值
>>>img.item(10,10,2)
59

#修改 红色通道 的值
>>>img.itemset((10,10,2),100)
>>>img.item(10,10,2)
100
```

## 访问图像属性

图像属性包括行数，列数和通道数，图像数据类型，像素数等。

与一般的numpy.array一样，可以通过 img.shape 访问图像的形状。它返回一组由图像的行、列和通道组成的元组（如果图像是彩色的）：

```python
>>>print(img.shape)
(128,128,3)
```

>**注意**
>如果图像是灰度图像，则返回的元组仅包含行数和列数，因此它是检查加载的图像是灰度图还是彩色图的一种很好的方法。

通过 img.size 访问图像的总像素数：

```python
>>>print(img.size)
562248
```

图像数据类型可以由 img.dtype 获得：

```python
>>>print(img.dtype)
UINT8
```
>**注意**
>img.dtype 在调试时非常重要，因为 OpenCV-Python 代码中的大量错误由无效的数据类型引起。

## 图像中的感兴趣区域

有时您将不得不处理某些图像区域。对于图像中的眼部检测，在整个图像上进行第一次面部检测。当获得面部后，我们单独选择面部区域并在其内部搜索眼部而不是搜索整个原始图像。它提高了准确性（因为眼睛总是在脸上：D）和性能（因为我们在一个小区域搜索）。

使用 Numpy 索引再次获得 ROI（感兴趣区域）。在这里，我选择球并将其复制到图像中的另一个区域：

```python
>>>ball = img[280:340,330:390]
>>>img[273:333,100:160]
```
查看以下结果：

<div align=center>
<img src="https://opencv.apachecn.org/docs/4.0.0/img/roi.jpg">
</div>

## 拆分和合并图像通道

有时您需要在 B，G，R 通道图像上单独工作。在这种情况下，您需要将 BGR 图像分割为单个通道。在其他情况下，您可能需要将这些单独的通道合并至 BGR 图像。您可以通过以下方式完成：
```python
>>>b,g,r = CV.spilt(img)
>>>img = CV.merge((b,g,r))
```
或者使用numpy.array的切片方法

```python
>>>b = img[:,:,0]
```
假设您要将所有红色像素设置为零，则无需先拆分通道。Numpy 索引更快：

```python
>>> img[:,:,2] = 0
```

**警告**

CV.spilt()是一项代价高昂的操作（就时间而言）。所以只在你需要时再这样做，否则使用 Numpy 索引。

## 制作图像边界（填充）

如果要在图像周围创建边框，比如相框，可以使用 CV.copyMakeBorder()。但它有更多卷积运算，零填充等应用。该函数采用以下参数：

* src-输入的图像
* top,bottom,left,right-上下左右四个方向上的边界拓宽的值
* borderType-定义要添加的边框类型的标志。它可以是以下类型：
>* [CV.BORDER_CONSTANT](https://docs.OpenCV.org/4.0.0/d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5aed2e4346047e265c8c5a6d0276dcd838)- 添加一个恒定的彩色边框。该值应作为下一个参数value给出。
>* [CV.BORDER_REFLECT](https://docs.OpenCV.org/4.0.0/d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5a815c8a89b7cb206dcba14d11b7560f4b)-边框将是边框元素的镜像反射，如下所示：fedcba|abcdefgh|hgfedcb
>* [CV.BORDER_REFLECT_101](https://docs.OpenCV.org/4.0.0/d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5ab3c5a6143d8120b95005fa7105a10bb4)或者[ CV.BORDER_DEFAULT](https://docs.OpenCV.org/4.0.0/d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5afe14c13a4ea8b8e3b3ef399013dbae01)-与上面相同，但略有改动，如下所示： gfedcb | abcdefgh | gfedcba
>* [CV.BORDER_REPLICATE ](https://docs.OpenCV.org/4.0.0/d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5aa1de4cff95e3377d6d0cbe7569bd4e9f)-最后一个元素被复制，如下所示： aaaaaa | abcdefgh | hhhhhhh
>* [CV.BORDER_WRAP](https://docs.OpenCV.org/4.0.0/d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5a697c1b011884a7c2bdc0e5caf7955661)-不好解释，它看起来像这样： cdefgh | abcdefgh | abcdefg

* value- 如果边框类型为[CV.BORDER_CONSTANT](https://docs.OpenCV.org/4.0.0/d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5aed2e4346047e265c8c5a6d0276dcd838)，则这个值即为要设置的边框颜色

下面是一个示例代码，演示了上述所有边框类型，以便更好地理解：

```python
import CV2 as CV
import numpy as np
from matplotlib import pyplot as plt
BLUE = [255,0,0]
img1 = CV.imread('OpenCV-logo.png')
replicate = CV.copyMakeBorder(img1,10,10,10,10,CV.BORDER_REPLICATE)
reflect = CV.copyMakeBorder(img1,10,10,10,10,CV.BORDER_REFLECT)
reflect101 = CV.copyMakeBorder(img1,10,10,10,10,CV.BORDER_REFLECT_101)
wrap = CV.copyMakeBorder(img1,10,10,10,10,CV.BORDER_WRAP)
constant= CV.copyMakeBorder(img1,10,10,10,10,CV.BORDER_CONSTANT,value=BLUE)
plt.subplot(231),plt.imshow(img1,'gray'),plt.title('ORIGINAL')
plt.subplot(232),plt.imshow(replicate,'gray'),plt.title('REPLICATE')
plt.subplot(233),plt.imshow(reflect,'gray'),plt.title('REFLECT')
plt.subplot(234),plt.imshow(reflect101,'gray'),plt.title('REFLECT_101')
plt.subplot(235),plt.imshow(wrap,'gray'),plt.title('WRAP')
plt.subplot(236),plt.imshow(constant,'gray'),plt.title('CONSTANT')
plt.show()
```

请参阅下面的结果。（图像是通过 matplotlib 展示的。因此互换了红色和蓝色通道）：

<div align=center>
<img src="https://opencv.apachecn.org/docs/4.0.0/img/border.jpg">
</div>

## 其他资源

## 练习
